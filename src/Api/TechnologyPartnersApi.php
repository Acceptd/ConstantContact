<?php
/**
 * TechnologyPartnersApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AppConnect V3
 *
 * The Constant Contact, Inc. V3 public API, for building integrations with Constant Contact, the leading small-business email marketing platform.
 *
 * The version of the OpenAPI document: 3.0.2400
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ConstantContact\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * TechnologyPartnersApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TechnologyPartnersApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'cancelAccount' => [
            'application/json',
        ],
        'createSSOUser' => [
            'application/json',
        ],
        'getPartnerSiteOwners' => [
            'application/json',
        ],
        'getPlan' => [
            'application/json',
        ],
        'partnerAccountOperationsPostSync' => [
            'application/json',
        ],
        'provision' => [
            'application/json',
        ],
        'setPlan' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation cancelAccount
     *
     * PUT Cancel the Billing Plan for a Client Account
     *
     * @param  string $encoded_account_id The system generated ID that uniquely identifies the client account. (required)
     * @param  \OpenAPI\Client\Model\AccountCancellation $body By default, the current date and time is automatically used as the cancellation date. However, you can specify a future date and time to cancel the account (&#x60;effective_date&#x60;) in the request body in ISO format. You can also enter the client&#39;s cancellation reason (&#x60;reason_id&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountCancellation
     */
    public function cancelAccount($encoded_account_id, $body = null, string $contentType = self::contentTypes['cancelAccount'][0])
    {
        list($response) = $this->cancelAccountWithHttpInfo($encoded_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation cancelAccountWithHttpInfo
     *
     * PUT Cancel the Billing Plan for a Client Account
     *
     * @param  string $encoded_account_id The system generated ID that uniquely identifies the client account. (required)
     * @param  \OpenAPI\Client\Model\AccountCancellation $body By default, the current date and time is automatically used as the cancellation date. However, you can specify a future date and time to cancel the account (&#x60;effective_date&#x60;) in the request body in ISO format. You can also enter the client&#39;s cancellation reason (&#x60;reason_id&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountCancellation, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelAccountWithHttpInfo($encoded_account_id, $body = null, string $contentType = self::contentTypes['cancelAccount'][0])
    {
        $request = $this->cancelAccountRequest($encoded_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AccountCancellation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AccountCancellation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AccountCancellation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AccountCancellation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountCancellation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelAccountAsync
     *
     * PUT Cancel the Billing Plan for a Client Account
     *
     * @param  string $encoded_account_id The system generated ID that uniquely identifies the client account. (required)
     * @param  \OpenAPI\Client\Model\AccountCancellation $body By default, the current date and time is automatically used as the cancellation date. However, you can specify a future date and time to cancel the account (&#x60;effective_date&#x60;) in the request body in ISO format. You can also enter the client&#39;s cancellation reason (&#x60;reason_id&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelAccountAsync($encoded_account_id, $body = null, string $contentType = self::contentTypes['cancelAccount'][0])
    {
        return $this->cancelAccountAsyncWithHttpInfo($encoded_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelAccountAsyncWithHttpInfo
     *
     * PUT Cancel the Billing Plan for a Client Account
     *
     * @param  string $encoded_account_id The system generated ID that uniquely identifies the client account. (required)
     * @param  \OpenAPI\Client\Model\AccountCancellation $body By default, the current date and time is automatically used as the cancellation date. However, you can specify a future date and time to cancel the account (&#x60;effective_date&#x60;) in the request body in ISO format. You can also enter the client&#39;s cancellation reason (&#x60;reason_id&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelAccountAsyncWithHttpInfo($encoded_account_id, $body = null, string $contentType = self::contentTypes['cancelAccount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountCancellation';
        $request = $this->cancelAccountRequest($encoded_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelAccount'
     *
     * @param  string $encoded_account_id The system generated ID that uniquely identifies the client account. (required)
     * @param  \OpenAPI\Client\Model\AccountCancellation $body By default, the current date and time is automatically used as the cancellation date. However, you can specify a future date and time to cancel the account (&#x60;effective_date&#x60;) in the request body in ISO format. You can also enter the client&#39;s cancellation reason (&#x60;reason_id&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelAccountRequest($encoded_account_id, $body = null, string $contentType = self::contentTypes['cancelAccount'][0])
    {

        // verify the required parameter 'encoded_account_id' is set
        if ($encoded_account_id === null || (is_array($encoded_account_id) && count($encoded_account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encoded_account_id when calling cancelAccount'
            );
        }



        $resourcePath = '/partner/accounts/{encoded_account_id}/status/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($encoded_account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'encoded_account_id' . '}',
                ObjectSerializer::toPathValue($encoded_account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Unnamed');
        if ($apiKey !== null) {
            $headers['Unnamed'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSSOUser
     *
     * POST a User Under a Partner&#39;s SSO-Enabled Client Account
     *
     * @param  string $encoded_account_id The encoded account ID that identifies the partner&#39;s client account to which to add the new user. (required)
     * @param  \OpenAPI\Client\Model\SSOUser $sso_user The JSON payload used to create a new user under the specified partner&#39;s client account. All request body properties are required (&#x60;first_name&#x60;, &#x60;last_name&#x60;, &#x60;role_name&#x60;, &#x60;contact_email&#x60;, &#x60;login_name&#x60;, &#x60;external_id&#x60;, &#x60;external_provider&#x60;). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSSOUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createSSOUser($encoded_account_id, $sso_user, string $contentType = self::contentTypes['createSSOUser'][0])
    {
        $this->createSSOUserWithHttpInfo($encoded_account_id, $sso_user, $contentType);
    }

    /**
     * Operation createSSOUserWithHttpInfo
     *
     * POST a User Under a Partner&#39;s SSO-Enabled Client Account
     *
     * @param  string $encoded_account_id The encoded account ID that identifies the partner&#39;s client account to which to add the new user. (required)
     * @param  \OpenAPI\Client\Model\SSOUser $sso_user The JSON payload used to create a new user under the specified partner&#39;s client account. All request body properties are required (&#x60;first_name&#x60;, &#x60;last_name&#x60;, &#x60;role_name&#x60;, &#x60;contact_email&#x60;, &#x60;login_name&#x60;, &#x60;external_id&#x60;, &#x60;external_provider&#x60;). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSSOUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createSSOUserWithHttpInfo($encoded_account_id, $sso_user, string $contentType = self::contentTypes['createSSOUser'][0])
    {
        $request = $this->createSSOUserRequest($encoded_account_id, $sso_user, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createSSOUserAsync
     *
     * POST a User Under a Partner&#39;s SSO-Enabled Client Account
     *
     * @param  string $encoded_account_id The encoded account ID that identifies the partner&#39;s client account to which to add the new user. (required)
     * @param  \OpenAPI\Client\Model\SSOUser $sso_user The JSON payload used to create a new user under the specified partner&#39;s client account. All request body properties are required (&#x60;first_name&#x60;, &#x60;last_name&#x60;, &#x60;role_name&#x60;, &#x60;contact_email&#x60;, &#x60;login_name&#x60;, &#x60;external_id&#x60;, &#x60;external_provider&#x60;). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSSOUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSSOUserAsync($encoded_account_id, $sso_user, string $contentType = self::contentTypes['createSSOUser'][0])
    {
        return $this->createSSOUserAsyncWithHttpInfo($encoded_account_id, $sso_user, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSSOUserAsyncWithHttpInfo
     *
     * POST a User Under a Partner&#39;s SSO-Enabled Client Account
     *
     * @param  string $encoded_account_id The encoded account ID that identifies the partner&#39;s client account to which to add the new user. (required)
     * @param  \OpenAPI\Client\Model\SSOUser $sso_user The JSON payload used to create a new user under the specified partner&#39;s client account. All request body properties are required (&#x60;first_name&#x60;, &#x60;last_name&#x60;, &#x60;role_name&#x60;, &#x60;contact_email&#x60;, &#x60;login_name&#x60;, &#x60;external_id&#x60;, &#x60;external_provider&#x60;). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSSOUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSSOUserAsyncWithHttpInfo($encoded_account_id, $sso_user, string $contentType = self::contentTypes['createSSOUser'][0])
    {
        $returnType = '';
        $request = $this->createSSOUserRequest($encoded_account_id, $sso_user, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSSOUser'
     *
     * @param  string $encoded_account_id The encoded account ID that identifies the partner&#39;s client account to which to add the new user. (required)
     * @param  \OpenAPI\Client\Model\SSOUser $sso_user The JSON payload used to create a new user under the specified partner&#39;s client account. All request body properties are required (&#x60;first_name&#x60;, &#x60;last_name&#x60;, &#x60;role_name&#x60;, &#x60;contact_email&#x60;, &#x60;login_name&#x60;, &#x60;external_id&#x60;, &#x60;external_provider&#x60;). (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSSOUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createSSOUserRequest($encoded_account_id, $sso_user, string $contentType = self::contentTypes['createSSOUser'][0])
    {

        // verify the required parameter 'encoded_account_id' is set
        if ($encoded_account_id === null || (is_array($encoded_account_id) && count($encoded_account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encoded_account_id when calling createSSOUser'
            );
        }

        // verify the required parameter 'sso_user' is set
        if ($sso_user === null || (is_array($sso_user) && count($sso_user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sso_user when calling createSSOUser'
            );
        }


        $resourcePath = '/partner/accounts/{encoded_account_id}/users/sso';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($encoded_account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'encoded_account_id' . '}',
                ObjectSerializer::toPathValue($encoded_account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sso_user)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($sso_user));
            } else {
                $httpBody = $sso_user;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Unnamed');
        if ($apiKey !== null) {
            $headers['Unnamed'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPartnerSiteOwners
     *
     * GET Partner Client Accounts
     *
     * @param  string $offset Depending on the &#x60;limit&#x60; you specify, the system determines the &#x60;offset&#x60; parameter to use (number of records to skip) and includes it in the link used to get the next page of results (optional)
     * @param  string $limit The number of client accounts to return on each page of results. The default value is &#x60;50&#x60;. Entering a &#x60;limit&#x60; value less than the minimum (&#x60;10&#x60;) or greater than the maximum (&#x60;50&#x60;) is ignored and the system uses the default values. Depending on the &#x60;limit&#x60; you specify, the system determines the &#x60;offset&#x60; parameter to use (number of records to skip) and includes it in the link used to get the next page of results. (optional, default to '50')
     * @param  string $account_type Filters client account results by account type: &#x60;all&#x60; (default), &#x60;managed&#x60;, or &#x60;unmanaged&#x60;. Excluding the &#x60;account_type&#x60; query parameter returns all client accounts for the partner. (optional, default to 'all')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPartnerSiteOwners'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PartnerAccount
     */
    public function getPartnerSiteOwners($offset = null, $limit = '50', $account_type = 'all', string $contentType = self::contentTypes['getPartnerSiteOwners'][0])
    {
        list($response) = $this->getPartnerSiteOwnersWithHttpInfo($offset, $limit, $account_type, $contentType);
        return $response;
    }

    /**
     * Operation getPartnerSiteOwnersWithHttpInfo
     *
     * GET Partner Client Accounts
     *
     * @param  string $offset Depending on the &#x60;limit&#x60; you specify, the system determines the &#x60;offset&#x60; parameter to use (number of records to skip) and includes it in the link used to get the next page of results (optional)
     * @param  string $limit The number of client accounts to return on each page of results. The default value is &#x60;50&#x60;. Entering a &#x60;limit&#x60; value less than the minimum (&#x60;10&#x60;) or greater than the maximum (&#x60;50&#x60;) is ignored and the system uses the default values. Depending on the &#x60;limit&#x60; you specify, the system determines the &#x60;offset&#x60; parameter to use (number of records to skip) and includes it in the link used to get the next page of results. (optional, default to '50')
     * @param  string $account_type Filters client account results by account type: &#x60;all&#x60; (default), &#x60;managed&#x60;, or &#x60;unmanaged&#x60;. Excluding the &#x60;account_type&#x60; query parameter returns all client accounts for the partner. (optional, default to 'all')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPartnerSiteOwners'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PartnerAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPartnerSiteOwnersWithHttpInfo($offset = null, $limit = '50', $account_type = 'all', string $contentType = self::contentTypes['getPartnerSiteOwners'][0])
    {
        $request = $this->getPartnerSiteOwnersRequest($offset, $limit, $account_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PartnerAccount' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PartnerAccount' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PartnerAccount', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PartnerAccount';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PartnerAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPartnerSiteOwnersAsync
     *
     * GET Partner Client Accounts
     *
     * @param  string $offset Depending on the &#x60;limit&#x60; you specify, the system determines the &#x60;offset&#x60; parameter to use (number of records to skip) and includes it in the link used to get the next page of results (optional)
     * @param  string $limit The number of client accounts to return on each page of results. The default value is &#x60;50&#x60;. Entering a &#x60;limit&#x60; value less than the minimum (&#x60;10&#x60;) or greater than the maximum (&#x60;50&#x60;) is ignored and the system uses the default values. Depending on the &#x60;limit&#x60; you specify, the system determines the &#x60;offset&#x60; parameter to use (number of records to skip) and includes it in the link used to get the next page of results. (optional, default to '50')
     * @param  string $account_type Filters client account results by account type: &#x60;all&#x60; (default), &#x60;managed&#x60;, or &#x60;unmanaged&#x60;. Excluding the &#x60;account_type&#x60; query parameter returns all client accounts for the partner. (optional, default to 'all')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPartnerSiteOwners'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPartnerSiteOwnersAsync($offset = null, $limit = '50', $account_type = 'all', string $contentType = self::contentTypes['getPartnerSiteOwners'][0])
    {
        return $this->getPartnerSiteOwnersAsyncWithHttpInfo($offset, $limit, $account_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPartnerSiteOwnersAsyncWithHttpInfo
     *
     * GET Partner Client Accounts
     *
     * @param  string $offset Depending on the &#x60;limit&#x60; you specify, the system determines the &#x60;offset&#x60; parameter to use (number of records to skip) and includes it in the link used to get the next page of results (optional)
     * @param  string $limit The number of client accounts to return on each page of results. The default value is &#x60;50&#x60;. Entering a &#x60;limit&#x60; value less than the minimum (&#x60;10&#x60;) or greater than the maximum (&#x60;50&#x60;) is ignored and the system uses the default values. Depending on the &#x60;limit&#x60; you specify, the system determines the &#x60;offset&#x60; parameter to use (number of records to skip) and includes it in the link used to get the next page of results. (optional, default to '50')
     * @param  string $account_type Filters client account results by account type: &#x60;all&#x60; (default), &#x60;managed&#x60;, or &#x60;unmanaged&#x60;. Excluding the &#x60;account_type&#x60; query parameter returns all client accounts for the partner. (optional, default to 'all')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPartnerSiteOwners'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPartnerSiteOwnersAsyncWithHttpInfo($offset = null, $limit = '50', $account_type = 'all', string $contentType = self::contentTypes['getPartnerSiteOwners'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PartnerAccount';
        $request = $this->getPartnerSiteOwnersRequest($offset, $limit, $account_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPartnerSiteOwners'
     *
     * @param  string $offset Depending on the &#x60;limit&#x60; you specify, the system determines the &#x60;offset&#x60; parameter to use (number of records to skip) and includes it in the link used to get the next page of results (optional)
     * @param  string $limit The number of client accounts to return on each page of results. The default value is &#x60;50&#x60;. Entering a &#x60;limit&#x60; value less than the minimum (&#x60;10&#x60;) or greater than the maximum (&#x60;50&#x60;) is ignored and the system uses the default values. Depending on the &#x60;limit&#x60; you specify, the system determines the &#x60;offset&#x60; parameter to use (number of records to skip) and includes it in the link used to get the next page of results. (optional, default to '50')
     * @param  string $account_type Filters client account results by account type: &#x60;all&#x60; (default), &#x60;managed&#x60;, or &#x60;unmanaged&#x60;. Excluding the &#x60;account_type&#x60; query parameter returns all client accounts for the partner. (optional, default to 'all')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPartnerSiteOwners'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPartnerSiteOwnersRequest($offset = null, $limit = '50', $account_type = 'all', string $contentType = self::contentTypes['getPartnerSiteOwners'][0])
    {


        


        $resourcePath = '/partner/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_type,
            'account_type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Unnamed');
        if ($apiKey !== null) {
            $headers['Unnamed'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPlan
     *
     * GET Billing Plan Details for a Client Account
     *
     * @param  string $encoded_account_id Specify the client&#39;s unique &#x60;encoded_account_id&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPlan'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PlanTiersObject
     */
    public function getPlan($encoded_account_id, string $contentType = self::contentTypes['getPlan'][0])
    {
        list($response) = $this->getPlanWithHttpInfo($encoded_account_id, $contentType);
        return $response;
    }

    /**
     * Operation getPlanWithHttpInfo
     *
     * GET Billing Plan Details for a Client Account
     *
     * @param  string $encoded_account_id Specify the client&#39;s unique &#x60;encoded_account_id&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPlan'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PlanTiersObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPlanWithHttpInfo($encoded_account_id, string $contentType = self::contentTypes['getPlan'][0])
    {
        $request = $this->getPlanRequest($encoded_account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PlanTiersObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PlanTiersObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PlanTiersObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PlanTiersObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PlanTiersObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPlanAsync
     *
     * GET Billing Plan Details for a Client Account
     *
     * @param  string $encoded_account_id Specify the client&#39;s unique &#x60;encoded_account_id&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPlanAsync($encoded_account_id, string $contentType = self::contentTypes['getPlan'][0])
    {
        return $this->getPlanAsyncWithHttpInfo($encoded_account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPlanAsyncWithHttpInfo
     *
     * GET Billing Plan Details for a Client Account
     *
     * @param  string $encoded_account_id Specify the client&#39;s unique &#x60;encoded_account_id&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPlanAsyncWithHttpInfo($encoded_account_id, string $contentType = self::contentTypes['getPlan'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PlanTiersObject';
        $request = $this->getPlanRequest($encoded_account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPlan'
     *
     * @param  string $encoded_account_id Specify the client&#39;s unique &#x60;encoded_account_id&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPlanRequest($encoded_account_id, string $contentType = self::contentTypes['getPlan'][0])
    {

        // verify the required parameter 'encoded_account_id' is set
        if ($encoded_account_id === null || (is_array($encoded_account_id) && count($encoded_account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encoded_account_id when calling getPlan'
            );
        }


        $resourcePath = '/partner/accounts/{encoded_account_id}/plan';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($encoded_account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'encoded_account_id' . '}',
                ObjectSerializer::toPathValue($encoded_account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Unnamed');
        if ($apiKey !== null) {
            $headers['Unnamed'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation partnerAccountOperationsPostSync
     *
     * POST Send an API request on Behalf of a Client Account
     *
     * @param  string $encoded_account_id An encoded account id for a managed account in your partnership. (required)
     * @param  \OpenAPI\Client\Model\PartnerAccountOperationsRequest $body A JSON request body that contains the structure of the HTTP request you are instructing Constant Contact to send on behalf of specific managed account in your partnership. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['partnerAccountOperationsPostSync'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function partnerAccountOperationsPostSync($encoded_account_id, $body = null, string $contentType = self::contentTypes['partnerAccountOperationsPostSync'][0])
    {
        $this->partnerAccountOperationsPostSyncWithHttpInfo($encoded_account_id, $body, $contentType);
    }

    /**
     * Operation partnerAccountOperationsPostSyncWithHttpInfo
     *
     * POST Send an API request on Behalf of a Client Account
     *
     * @param  string $encoded_account_id An encoded account id for a managed account in your partnership. (required)
     * @param  \OpenAPI\Client\Model\PartnerAccountOperationsRequest $body A JSON request body that contains the structure of the HTTP request you are instructing Constant Contact to send on behalf of specific managed account in your partnership. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['partnerAccountOperationsPostSync'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function partnerAccountOperationsPostSyncWithHttpInfo($encoded_account_id, $body = null, string $contentType = self::contentTypes['partnerAccountOperationsPostSync'][0])
    {
        $request = $this->partnerAccountOperationsPostSyncRequest($encoded_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation partnerAccountOperationsPostSyncAsync
     *
     * POST Send an API request on Behalf of a Client Account
     *
     * @param  string $encoded_account_id An encoded account id for a managed account in your partnership. (required)
     * @param  \OpenAPI\Client\Model\PartnerAccountOperationsRequest $body A JSON request body that contains the structure of the HTTP request you are instructing Constant Contact to send on behalf of specific managed account in your partnership. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['partnerAccountOperationsPostSync'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function partnerAccountOperationsPostSyncAsync($encoded_account_id, $body = null, string $contentType = self::contentTypes['partnerAccountOperationsPostSync'][0])
    {
        return $this->partnerAccountOperationsPostSyncAsyncWithHttpInfo($encoded_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation partnerAccountOperationsPostSyncAsyncWithHttpInfo
     *
     * POST Send an API request on Behalf of a Client Account
     *
     * @param  string $encoded_account_id An encoded account id for a managed account in your partnership. (required)
     * @param  \OpenAPI\Client\Model\PartnerAccountOperationsRequest $body A JSON request body that contains the structure of the HTTP request you are instructing Constant Contact to send on behalf of specific managed account in your partnership. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['partnerAccountOperationsPostSync'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function partnerAccountOperationsPostSyncAsyncWithHttpInfo($encoded_account_id, $body = null, string $contentType = self::contentTypes['partnerAccountOperationsPostSync'][0])
    {
        $returnType = '';
        $request = $this->partnerAccountOperationsPostSyncRequest($encoded_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'partnerAccountOperationsPostSync'
     *
     * @param  string $encoded_account_id An encoded account id for a managed account in your partnership. (required)
     * @param  \OpenAPI\Client\Model\PartnerAccountOperationsRequest $body A JSON request body that contains the structure of the HTTP request you are instructing Constant Contact to send on behalf of specific managed account in your partnership. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['partnerAccountOperationsPostSync'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function partnerAccountOperationsPostSyncRequest($encoded_account_id, $body = null, string $contentType = self::contentTypes['partnerAccountOperationsPostSync'][0])
    {

        // verify the required parameter 'encoded_account_id' is set
        if ($encoded_account_id === null || (is_array($encoded_account_id) && count($encoded_account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encoded_account_id when calling partnerAccountOperationsPostSync'
            );
        }



        $resourcePath = '/partner/accounts/{encoded_account_id}/account_operations/sync';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($encoded_account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'encoded_account_id' . '}',
                ObjectSerializer::toPathValue($encoded_account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Unnamed');
        if ($apiKey !== null) {
            $headers['Unnamed'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation provision
     *
     * POST (create) a Partner Client Account
     *
     * @param  \OpenAPI\Client\Model\Provision $provision Create a new Constant Contact client account under your partner account. All required properties must be included in the JSON payload request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provision'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProvisionResponse
     */
    public function provision($provision, string $contentType = self::contentTypes['provision'][0])
    {
        list($response) = $this->provisionWithHttpInfo($provision, $contentType);
        return $response;
    }

    /**
     * Operation provisionWithHttpInfo
     *
     * POST (create) a Partner Client Account
     *
     * @param  \OpenAPI\Client\Model\Provision $provision Create a new Constant Contact client account under your partner account. All required properties must be included in the JSON payload request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provision'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProvisionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function provisionWithHttpInfo($provision, string $contentType = self::contentTypes['provision'][0])
    {
        $request = $this->provisionRequest($provision, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ProvisionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProvisionResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProvisionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProvisionResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProvisionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation provisionAsync
     *
     * POST (create) a Partner Client Account
     *
     * @param  \OpenAPI\Client\Model\Provision $provision Create a new Constant Contact client account under your partner account. All required properties must be included in the JSON payload request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provision'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function provisionAsync($provision, string $contentType = self::contentTypes['provision'][0])
    {
        return $this->provisionAsyncWithHttpInfo($provision, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation provisionAsyncWithHttpInfo
     *
     * POST (create) a Partner Client Account
     *
     * @param  \OpenAPI\Client\Model\Provision $provision Create a new Constant Contact client account under your partner account. All required properties must be included in the JSON payload request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provision'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function provisionAsyncWithHttpInfo($provision, string $contentType = self::contentTypes['provision'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProvisionResponse';
        $request = $this->provisionRequest($provision, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'provision'
     *
     * @param  \OpenAPI\Client\Model\Provision $provision Create a new Constant Contact client account under your partner account. All required properties must be included in the JSON payload request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provision'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function provisionRequest($provision, string $contentType = self::contentTypes['provision'][0])
    {

        // verify the required parameter 'provision' is set
        if ($provision === null || (is_array($provision) && count($provision) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provision when calling provision'
            );
        }


        $resourcePath = '/partner/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provision)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provision));
            } else {
                $httpBody = $provision;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Unnamed');
        if ($apiKey !== null) {
            $headers['Unnamed'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setPlan
     *
     * PUT (update) Billing Plan Details for a Client Account
     *
     * @param  string $encoded_account_id Specify the client&#39;s unique &#x60;encoded_account_id&#x60;. (required)
     * @param  \OpenAPI\Client\Model\PlanInfo $body Update the billing plan (&#x60;plan_type&#x60;) for an existing Constant Contact client account. Options include:   - &#x60;TRIAL&#x60;: A non-billed account with an expiration date that allows clients to try Constant Contact product features.    - &#x60;GOLD&#x60;: A billable plan that provides all available product features.    - &#x60;SILVER&#x60;: A billable plan that provides all features available in the &lt;code&gt;BRONZE&lt;/code&gt; plan, and adds some additional email campaign feature such as contact segmentation and social media advertisements.    - &#x60;BRONZE&#x60;: A billable plan that provides basic email and marketing tools.   If updating from a &#x60;TRIAL&#x60; plan (&#x60;plan_type&#x60;) to another type of billing plan, you have the option to update the day of month (&#x60;billing_day_of_month&#x60;) in which to bill the client account. Valid values include &#x60;1&#x60; through to and including &#x60;31&#x60;. Any additional billing plan properties and values that you include in the request body are ignored. If you are not on the latest billing plan, contact the Constant Contact Partner Team. However, older billing plans and &#x60;plan_type&#x60; enum values will continue to be supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPlan'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PlanTiersObject
     */
    public function setPlan($encoded_account_id, $body = null, string $contentType = self::contentTypes['setPlan'][0])
    {
        list($response) = $this->setPlanWithHttpInfo($encoded_account_id, $body, $contentType);
        return $response;
    }

    /**
     * Operation setPlanWithHttpInfo
     *
     * PUT (update) Billing Plan Details for a Client Account
     *
     * @param  string $encoded_account_id Specify the client&#39;s unique &#x60;encoded_account_id&#x60;. (required)
     * @param  \OpenAPI\Client\Model\PlanInfo $body Update the billing plan (&#x60;plan_type&#x60;) for an existing Constant Contact client account. Options include:   - &#x60;TRIAL&#x60;: A non-billed account with an expiration date that allows clients to try Constant Contact product features.    - &#x60;GOLD&#x60;: A billable plan that provides all available product features.    - &#x60;SILVER&#x60;: A billable plan that provides all features available in the &lt;code&gt;BRONZE&lt;/code&gt; plan, and adds some additional email campaign feature such as contact segmentation and social media advertisements.    - &#x60;BRONZE&#x60;: A billable plan that provides basic email and marketing tools.   If updating from a &#x60;TRIAL&#x60; plan (&#x60;plan_type&#x60;) to another type of billing plan, you have the option to update the day of month (&#x60;billing_day_of_month&#x60;) in which to bill the client account. Valid values include &#x60;1&#x60; through to and including &#x60;31&#x60;. Any additional billing plan properties and values that you include in the request body are ignored. If you are not on the latest billing plan, contact the Constant Contact Partner Team. However, older billing plans and &#x60;plan_type&#x60; enum values will continue to be supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPlan'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PlanTiersObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function setPlanWithHttpInfo($encoded_account_id, $body = null, string $contentType = self::contentTypes['setPlan'][0])
    {
        $request = $this->setPlanRequest($encoded_account_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PlanTiersObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PlanTiersObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PlanTiersObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PlanTiersObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PlanTiersObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setPlanAsync
     *
     * PUT (update) Billing Plan Details for a Client Account
     *
     * @param  string $encoded_account_id Specify the client&#39;s unique &#x60;encoded_account_id&#x60;. (required)
     * @param  \OpenAPI\Client\Model\PlanInfo $body Update the billing plan (&#x60;plan_type&#x60;) for an existing Constant Contact client account. Options include:   - &#x60;TRIAL&#x60;: A non-billed account with an expiration date that allows clients to try Constant Contact product features.    - &#x60;GOLD&#x60;: A billable plan that provides all available product features.    - &#x60;SILVER&#x60;: A billable plan that provides all features available in the &lt;code&gt;BRONZE&lt;/code&gt; plan, and adds some additional email campaign feature such as contact segmentation and social media advertisements.    - &#x60;BRONZE&#x60;: A billable plan that provides basic email and marketing tools.   If updating from a &#x60;TRIAL&#x60; plan (&#x60;plan_type&#x60;) to another type of billing plan, you have the option to update the day of month (&#x60;billing_day_of_month&#x60;) in which to bill the client account. Valid values include &#x60;1&#x60; through to and including &#x60;31&#x60;. Any additional billing plan properties and values that you include in the request body are ignored. If you are not on the latest billing plan, contact the Constant Contact Partner Team. However, older billing plans and &#x60;plan_type&#x60; enum values will continue to be supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPlanAsync($encoded_account_id, $body = null, string $contentType = self::contentTypes['setPlan'][0])
    {
        return $this->setPlanAsyncWithHttpInfo($encoded_account_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setPlanAsyncWithHttpInfo
     *
     * PUT (update) Billing Plan Details for a Client Account
     *
     * @param  string $encoded_account_id Specify the client&#39;s unique &#x60;encoded_account_id&#x60;. (required)
     * @param  \OpenAPI\Client\Model\PlanInfo $body Update the billing plan (&#x60;plan_type&#x60;) for an existing Constant Contact client account. Options include:   - &#x60;TRIAL&#x60;: A non-billed account with an expiration date that allows clients to try Constant Contact product features.    - &#x60;GOLD&#x60;: A billable plan that provides all available product features.    - &#x60;SILVER&#x60;: A billable plan that provides all features available in the &lt;code&gt;BRONZE&lt;/code&gt; plan, and adds some additional email campaign feature such as contact segmentation and social media advertisements.    - &#x60;BRONZE&#x60;: A billable plan that provides basic email and marketing tools.   If updating from a &#x60;TRIAL&#x60; plan (&#x60;plan_type&#x60;) to another type of billing plan, you have the option to update the day of month (&#x60;billing_day_of_month&#x60;) in which to bill the client account. Valid values include &#x60;1&#x60; through to and including &#x60;31&#x60;. Any additional billing plan properties and values that you include in the request body are ignored. If you are not on the latest billing plan, contact the Constant Contact Partner Team. However, older billing plans and &#x60;plan_type&#x60; enum values will continue to be supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPlanAsyncWithHttpInfo($encoded_account_id, $body = null, string $contentType = self::contentTypes['setPlan'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PlanTiersObject';
        $request = $this->setPlanRequest($encoded_account_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setPlan'
     *
     * @param  string $encoded_account_id Specify the client&#39;s unique &#x60;encoded_account_id&#x60;. (required)
     * @param  \OpenAPI\Client\Model\PlanInfo $body Update the billing plan (&#x60;plan_type&#x60;) for an existing Constant Contact client account. Options include:   - &#x60;TRIAL&#x60;: A non-billed account with an expiration date that allows clients to try Constant Contact product features.    - &#x60;GOLD&#x60;: A billable plan that provides all available product features.    - &#x60;SILVER&#x60;: A billable plan that provides all features available in the &lt;code&gt;BRONZE&lt;/code&gt; plan, and adds some additional email campaign feature such as contact segmentation and social media advertisements.    - &#x60;BRONZE&#x60;: A billable plan that provides basic email and marketing tools.   If updating from a &#x60;TRIAL&#x60; plan (&#x60;plan_type&#x60;) to another type of billing plan, you have the option to update the day of month (&#x60;billing_day_of_month&#x60;) in which to bill the client account. Valid values include &#x60;1&#x60; through to and including &#x60;31&#x60;. Any additional billing plan properties and values that you include in the request body are ignored. If you are not on the latest billing plan, contact the Constant Contact Partner Team. However, older billing plans and &#x60;plan_type&#x60; enum values will continue to be supported. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setPlanRequest($encoded_account_id, $body = null, string $contentType = self::contentTypes['setPlan'][0])
    {

        // verify the required parameter 'encoded_account_id' is set
        if ($encoded_account_id === null || (is_array($encoded_account_id) && count($encoded_account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encoded_account_id when calling setPlan'
            );
        }



        $resourcePath = '/partner/accounts/{encoded_account_id}/plan';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($encoded_account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'encoded_account_id' . '}',
                ObjectSerializer::toPathValue($encoded_account_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Unnamed');
        if ($apiKey !== null) {
            $headers['Unnamed'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
